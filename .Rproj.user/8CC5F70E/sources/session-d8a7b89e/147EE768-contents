#' Inverted versions of `%in%`
#'
#' @export
#'
#' @examples
#' 1 %nin% 1:10
#' "A" %nin% 1:10
`%nin%` <- function(x, table) {
  match(x, table, nomatch = 0) == 0
}


#' Custom `skimr::skim()` for numeric variables
#'
#' @description
#' The custom `skimr::skim_with()`
#'
#' @export df_skim
#'
#' @importFrom skimr skim_with skim
#' @examples
#' num_skim(mtcars)
df_skim <- function(df) {
  skims <- list(numeric =
                sfl(min = ~ min(., na.rm = TRUE),
                    med = ~ median(., na.rm = TRUE),
                    p0 = NULL, p25 = NULL, p50 = NULL,
                    p75 = NULL, p100 = NULL,
                    max = ~ max(., na.rm = TRUE),
                    iqr = ~ IQR(., na.rm = TRUE)),
                factor =
                    sfl(ordered = NULL),
                character =
                    sfl(min = NULL, max = NULL, whitespace = NULL)
    )
  df_skim <- skimr::skim_with(!!!skims)
  df_skim(df)
}

#' Deconstruct R objects
#'
#' @param x R object passed to `dput()`
#' @param quotes include quotes in the output
#' @param console logical, used in the console? If `FALSE`, then output is printed
#' with `base::noquote()`. If `TRUE`, output is returned with `cat()`
#'
#' @return Deparsed object
#' @export deconstruct
#'
#'
#' @examples
#' x <- deconstruct(names(mtcars), return = TRUE)
#' x
#' deconstruct(names(mtcars))
deconstruct <- function(x, return = FALSE, quote = TRUE) {
  raw_obj <- capture.output(dput(x, control = "all"))
  if (isFALSE(quote)) {
    obj_noquote <- gsub(pattern = '"', replacement = "", x = raw_obj)
    decon_noquote <- paste0(obj_noquote, collapse = "")
    decon_obj <- gsub("\\s+", " ", decon_noquote)
  } else {
    obj_quote <- gsub(pattern = '"', replacement = "'", x = raw_obj)
    decon_quote <- paste0(obj_quote, collapse = "")
    decon_obj <- gsub("\\s+", " ", decon_quote)
  }
  if (isFALSE(return)) {
    base::cat(decon_obj)
  } else {
    return(noquote(decon_obj))
  }
}
#' Make UI inputs
#'
#' @description
#' This is meant to be used in the console--it generates the code for assigning
#' the elements from a list into a collection of vectors.
#'
#' @param app_data dataset for app (`data.frame` or `tibble`)
#'
#' @return zeallot assignment (`%<-%`) with input character vector on LHS and
#'    list of names by type on the RHS
#'
#' @export make_ui_inputs
#'
#' @examples
#' require(palmerpenguins)
#' make_ui_inputs(palmerpenguins::penguins)
#' require(zeallot)
#' c(double_vars, integer_vars, factor_vars) %<-%
#'   list(
#'     double_vars = c("bill_length_mm", "bill_depth_mm"),
#'     integer_vars = c("flipper_length_mm", "body_mass_g", "year"),
#'     factor_vars = c("species", "island", "sex")
#'   )
#' double_vars
#' integer_vars
#' factor_vars
make_ui_inputs <- function(app_data) {
  ui_inputs <- names(col_type_list(df = app_data))
  lhs_out <- deconstruct(x = ui_inputs, return = TRUE, quote = FALSE)
  zeallot_operator <- deconstruct(x = "%<-%", return = TRUE, quote = FALSE)
  rhs_out <- deconstruct(x = col_type_list(df = app_data), return = TRUE)
  cat(lhs_out, zeallot_operator, rhs_out)
}
# https://stackoverflow.com/questions/28221755/how-to-split-a-r-data-frame-into-vectors-unbind
